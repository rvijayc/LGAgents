import pdb
import subprocess
import os
import logging
import tempfile, tarfile
from typing import Optional, List

import docker
from docker import DockerClient
from langgraph.prebuilt import ToolNode
from pydantic import BaseModel, Field
from langchain_core.runnables import RunnableConfig
from langchain_core.tools import tool

from external.AgentRun.agentrun import AgentRun, PIPInstallPolicy

class PythonRunnerTool:

    def __init__(self, docker_root: Optional[str]=None):
        """
        Initialize the PythonRunnerTool.

        Args:
            docker_root: Specify the path that contains the docker config files
                (docker_compose.yml).
        """
        self.log = logging.getLogger('PYTHON_RUNNER')
        self.client: DockerClient = docker.from_env()
        if not docker_root:
            script_path = os.path.dirname(os.path.abspath(__file__))
            self.code_runner_path = os.path.join(script_path, 'code_runner')
        else:
            self.code_runner_path = docker_root

    def __enter__(self):
        self.log.info('Starting Python Runner Docker Image ...')
        subprocess.run(
                ['docker', 'compose', 'up', '--build', '-d'], 
                cwd=self.code_runner_path,
                check=True
                )
        # initialize the agent runner.
        self.container = self.client.containers.get('code_runner-python_runner-1')
        self.python_runner = AgentRun(
                container_name="code_runner-python_runner-1",
                cached_dependencies = [],
                install_policy=PIPInstallPolicy()
                )
        self.tool_node = ToolNode([run_python_tool], name="run_python")
        self.tmpdir = tempfile.TemporaryDirectory()
        return self

    def execute_code(self, code: str):
        return self.python_runner.execute_code_in_container(code)

    def configure(self, config: RunnableConfig):
        config['configurable']['python_runner'] = self

    def copy_file_from_container(
            self, 
            src_path: str,
            dst_folder: Optional[str]=None
            ) -> str:

        try:
            # get the archive
            stream, _ = self.container.get_archive(src_path)
        except docker.errors.NotFound:
            raise RuntimeError(f'{src_path} is inaccessible. Can you try a different absolute folder path instead?')

        # use temporary folder itself if destination isn't specified.
        if not dst_folder:
            dst_folder = os.path.join(self.tmpdir.name)
        
        with tempfile.NamedTemporaryFile(delete_on_close=False) as tmpfp:

            # write the tar stream on to a temporary file ...
            for chunk in stream:
                tmpfp.write(chunk)
            tmpfp.close()

            # ... and extract it.
            with tarfile.open(tmpfp.name) as tar:
                tar.extractall(dst_folder)

        # return the destination file name.
        dst_path = os.path.join(dst_folder, os.path.basename(src_path))
        assert os.path.isfile(dst_path)
        return dst_path

    def runner_tool_node(self) -> ToolNode:
        return self.tool_node

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.log.info('Stopping Python Runner Docker Image ...')
        subprocess.run(
                ['docker', 'compose', 'down'],
                cwd=self.code_runner_path,
                check=True
                )
        self.tmpdir.cleanup()

class PythonToolOutput(BaseModel):
    stdout: str = Field(description="Text output of the Python Program")
    artifacts_abs_paths: List[str] = Field(description="""
    Local paths of artifacts (if any) generated by the Python program, corresponding to the input `artifacts_abs_path` parameter. 
    """)

# create a tool.
@tool("run_python_tool", parse_docstring=True)
def run_python_tool(python_code: str, artifacts_abs_paths: List[str], config: RunnableConfig) -> PythonToolOutput:
    """
    Runs the specified python code provided and returns the standard output
    text. This tool doesn't have any display capabilities, and hence, if you
    wish to generate a plot, store the plot/figure into a PNG file and specify
    its absolute path in the `artifacts_abs_paths` parameter. 

    Always store artifacts such as plots in the `/code/artifacts` folder. The
    `artifacts_abs_paths` parameter allows you to generate and pass multiple
    artifact paths. Pass an empty list if no artifacts are generated by the
    program. The tool returns correct local paths in its output. Use these
    paths instead to refer to these artifacts in your conversation.

    Args:
        python_code: Python code to run provided as a string.
        artifacts_abs_paths: If the python code is generating a artifact (such
            as a plot), specify the absolute path of the files containing the
            artifacts.
    """
    python_tool: PythonRunnerTool = config['configurable']['python_runner']
    python_runner = python_tool.python_runner
    if not python_runner:
        raise RuntimeError('Python runner is not configured by the runtime configuration!')
    output = python_runner.execute_code_in_container(python_code)
    local_files = []
    for cont_path in artifacts_abs_paths:
        # copy the file locally
        local_files.append(python_tool.copy_file_from_container(cont_path))
    return PythonToolOutput(
            stdout=output,
            artifacts_abs_paths=local_files
    )


