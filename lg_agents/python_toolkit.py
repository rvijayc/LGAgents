import sys
import pdb
import os
from typing import Optional, List
import abc

from langgraph.prebuilt import ToolNode
from pydantic import BaseModel, Field
from langchain_core.runnables import RunnableConfig
from langchain_core.tools import StructuredTool
from langchain.output_parsers import PydanticOutputParser
from langchain_core.tools import BaseTool, ArgsSchema, BaseToolkit

from loguru import logger

from agentrun_plus import (
        AgentRunAPIClient, SessionInfo
)

class PythonToolInput(BaseModel):
    python_code: str = Field(description=" Python code to run provided as a string.")
    artifacts_paths: List[str] = Field(description="""
    If the python code is generating a artifact (such as a plot), specify the
    paths of the files containing the artifacts.
    """)

class PythonToolOutput(BaseModel):
    stdout: str = Field(description="Text output of the Python Program")
    user_artifacts_paths: List[str] = Field(description="""
    Local paths of artifacts (if any) generated by the Python program, corresponding to the input `artifacts_paths` parameter. This is only meant for user display. You can continue to use the original artifact locations for further use in downstream tool calls.
    """)

PYTHON_TOOL_DESCRIPTION="""
Runs the specified python code provided and returns the standard output
text. This tool doesn't have any display capabilities, and hence, if you
wish to generate a plot, store the plot/figure into a PNG file and specify
its path in the `artifacts_paths` parameter. 

Your code will run in a docker environment with a basic python base image
(`python:3.12.2-slim-bullseye`) and the following packages installed:

{packages}

So, restrict your code accordingly.

Always store artifacts such as plots in the `artifacts` folder relative to the
current folder in which the script is running. folder. The
`artifacts_paths` parameter allows you to generate and pass multiple
artifact paths. Pass an empty list if no artifacts are generated by the
program. DO NOT use any other folder to store artifacts.

The tool returns modified locations that you can pass to the user, but you can
continue to refer to the original locations (in `artifacts` relative to current
running folder) for referencing in downstream invocations of the tool.

The tool output follows this schema:
{output_schema}
"""
class PythonAppPolicy(abc.ABC):
    """
    This policy class allows an application to customize the "PythonRunner"
    tool for their use case. The code that an LLM produces will run inside a
    Docker container with a few specific requirements that are described in the
    docstring for PythonRunnerToolContext.

    You can work with the following assumptions.

    - `src`: A folder relative to the current working folder that hosts any
      source files needed to expose the any objects to the LLM. 
        - As an example, a SQL agent will host a file called "database.py"
          inside the "src/" folder from which an LLM can import the engine
          object using a line such as `from src.database import engine`. Any
          additional files needed by the application (such as an sqlite
          database), can be copied to this folder by overriding the
          `files_to_copy` method.
    - `artifacts`: A folder relative the current running folder contains
      artifacts generated by the LLM code (such as PNG plots).
    """
    def files_to_copy(self) -> List[str]:
        """
        Specify a list of files to copy into the working directory of the
        Docker Container.
        """
        return []

class PythonRunnerToolContext():
    """
    # Requirements 
    
    An agent run instance must be up and running before creating the python
    runner.
    """

    def __init__(self, 
                 agentrun_url: str,
                 app_policy: PythonAppPolicy,
                 tmpdir: str,
                 ignore_dependencies: Optional[List[str]]=None,
                 ignore_unsafe_functions: Optional[List[str]]=None,
                 debug=False,
    ):
        """
        Initialize the PythonRunnerTool.

        Args:
            agentrun_url: The full URL (host:port) of the AgentRun instance
                that will run the python code.
            tmpdir: A temporary folder to store temporary files (to be deleted
                on program exit). Use the tempfile.TemporaryDirectory context
                manager for this.
        """
        # latch parameters.
        self.debug = debug
        self.client: AgentRunAPIClient = AgentRunAPIClient(base_url=agentrun_url)
        self.ignore_dependencies = ignore_dependencies
        self.ignore_unsafe_functions = ignore_unsafe_functions
        self.tmpdir = tmpdir
        self.app_policy = app_policy

        # initializations.
        self._tool_node: Optional[ToolNode] = None
        self._tool: Optional[StructuredTool] = None
        self.log = logger.bind(name="Python-Runner")
        self.log.remove()
        self.log.add(
                sys.stderr,
                format="{time} {level} {message}",
                level="INFO",
                enqueue=True
        )

        # check if the agentrun server is healthy.
        response = self.client.get_health()
        if response['status'] != 'healthy':
            raise RuntimeError(f'AgentRun server {agentrun_url} failed health check!')
        self.log.info(f'AgentRun server {agentrun_url} running with {response["active_sessions"]} active sessions!')

        # create a new session.
        self.ar_session: SessionInfo = self.client.create_session()

        # copy any files the application needs.
        for file in self.app_policy.files_to_copy():
            self.client.upload_file(
                    session_id=self.ar_session.session_id,
                    file_path=file,
                    filename=os.path.basename(file)
            )

    def copy_code_to_container(
            self,
            python_code: str,
            dest_file_path: str):
        self.client.upload_file_content(
                session_id=self.ar_session.session_id,
                content=python_code.encode(),
                filename=os.path.basename(dest_file_path)
        )

    def execute_code(self, code: str):
        exec_result = self.client.execute_code(
                session_id=self.ar_session.session_id,
                python_code=code,
                ignore_dependencies=self.ignore_dependencies,
                ignore_unsafe_functions=self.ignore_unsafe_functions
        )
        return exec_result['output']


    def configure(self, config: RunnableConfig):
        config['configurable']['python_runner'] = self  # pyright: ignore[reportTypedDictNotRequiredAccess]

    def get_requirements_txt(
            self,
            fmt="markdown"
    ) -> str:
        lines = [
            "sqlalchemy",
            "numpy", 
            "pandas", 
            "matplotlib", 
            "seaborn", 
            "scikit-learn", 
            "statsmodels",
            "geopandas",
            "squarify",
            "tabulate",
            "prettytable"
        ]
        match fmt:
            case 'markdown':
                lines = [ f'  - {line.rstrip()}' for line in lines ]
                return '\n'.join(lines)
            case _: 
                raise RuntimeError(f'Unknown format: {format}!')

    def copy_file_from_container(
            self, 
            src_path: str,
            dst_folder: Optional[str]=None
            ) -> str:
        if dst_folder is None:
            dst_folder = self.tmpdir
        return self.client.download_file(
                session_id=self.ar_session.session_id,
                src_path=src_path,
                dest_path=dst_folder,
                filename=os.path.basename(src_path)
        )

class PythonRunnerTool(BaseTool):

    # overrides from BaseTool
    name: str = "run_python_tool"
    args_schema: ArgsSchema | None = PythonToolInput 
    description: str = ""   # fill this in during construction.
    return_direct: bool = True

    # our configuration.
    config: PythonRunnerToolContext
    
    def _run(
            self,
            python_code: str,
            artifacts_paths: List[str]
    ):
        try:
            python_runner = self.config
            output = python_runner.execute_code(python_code)
            local_files = []
            for cont_path in artifacts_paths:
                # copy the file locally
                local_files.append(python_runner.copy_file_from_container(cont_path))
            return PythonToolOutput(
                    stdout=output,
                    user_artifacts_paths=local_files
            )
        except Exception as e:
            raise

class PythonRunnerToolkit(BaseToolkit):
    tools: List[BaseTool]

    @classmethod
    def from_context(
            cls,
            config: PythonRunnerToolContext = Field(exclude=True)
    ):
        output_schema = PydanticOutputParser(pydantic_object=PythonToolOutput).get_output_jsonschema()
        packages = config.get_requirements_txt(fmt='markdown')
        return cls(
                tools=[
                    PythonRunnerTool(
                        description=PYTHON_TOOL_DESCRIPTION.format(
                            output_schema=output_schema,
                            packages=packages,
                        ),
                        config=config
                    )
                ]
            )

    def get_tools(self) -> List[BaseTool]:
        return self.tools
